Просто запустив приложение изолированно и, параллельно запуская другие, может случиться так, что нашим компонентам сайта  опросту не хватит аппаратных ресурсов, что приведет к замедлению работы в лучшем случае, в худшем - к полной неработоспособности нашего сайта. Для решения этой задачи в ядре ОС Linux уже встроен специальный механизм:
механизм контрольных групп (cgroups (control groups)).

**cgroup** — это механизм для иерархической организации процессов и распределения системных ресурсов.

**Историческая справка**

Разработка данного механизма была начата инженерами из Google в 2006 году и изначально имела иное название - контейнеры процессов, а уже после, в 2007 году, был переименован в механизм контрольных групп. Связано это было с тем, что мировое сообщество двояко расшифровывало термин контейнер в
изначальном определении.
Изначальное назначение утилиты было довольно простым: усовершенствование имеющегося механизма cpuset, который отвечал за распределение процессорного времени и оперативной памяти между всеми запущенными процессами и задачами. Однако, со временем проект перерос себя и был переориентирован.
Данная технология начала встраиваться в официальные версии ядра
несколько позже (в 2008 году), начиная с версии 2.6.24, когда была доработана и протестирована. С момента добавления в ядро, разработка значительно ускорилась и было добавлено много дополнительных возможностей, а механизм начал использоваться в технологии инициализации **systemd**, являясь при этом ключевым
элементом в реализации системы виртуализации на уровне  перационной системы LXC.

**LXC подсистема контейнеризации**

Механизм предоставляет ряд возможностей:
- Ограничение ресурсов (как виртуальных, так и физических) - использование
памяти и процессорного времени.
- Приоритизация. Разным группам приложений можно выделить различное
количество ресурсов процессора и, например, пропускной способности
ввода-вывода (дисковой подсистемы).
- Регистрация затрат тех или иных ресурсов приложением либо группой
приложений.
- Изоляция. Предполагается, что приложения используют распределенное
пространство имен таким образом, что процессы одной группы недоступны
другой. Та же участь касается и сетевой инфраструктуры и прочих ресурсов.
- Управление. Возможность перезагрузки процессов, создания
дополнительных квот и ограничений.
Механизм состоит из двух главных частей: ядра (cgroup core) и подсистем.

Список подсистем зависит от версии ядра. Основные компоненты следующие:

- blkio — подсистема устанавливает квоты на чтение и запись с блочных устройств.
- cpuacct — формирует отчеты об использовании ресурсов процессора.
- cpu — предоставляет доступ процессам в рамках контрольной группы к ресурсам процессорной подсистемы.
- cpuset — распределяет задачи в рамках контрольной группы между
имеющимися процессорными ядрами.
- devices — предоставляет доступ или же, наоборот, блокирует доступ к устройствам.
- freezer — приостанавливает и возобновляет выполнение задач в рамках контрольной группы.
- memory — занимается выделением памяти для групп процессов.
- net_cls — помечает сетевые пакеты специальным тэгом, который в
дальнейшем позволяет идентифицировать пакеты, порождаемые
определённой задачей в рамках контрольной группы.
- netprio — используется для динамической установки приоритетов по трафику.
- ns - используется для группировки процессов в отдельное пространство имен, где процессы могут взаимодействовать между собой и при этом будут изолированы от внешних процессов.
- pids — используется для ограничения количества процессов в рамках контрольной группы.
- unified — автоматически монтирует файловую систему в каталог
/sys/fs/cgroup/unified при запуске системы.

Помимо специализированных файлов, каждая директория содержит в себе набор управляющих файлов:

- cgroup.clone_children — позволяет передавать дочерним контрольным группам свойства родительских.
- tasks — содержит список PID всех процессов, включённых в контрольные группы.
- cgroup.procs — содержит список TGID (Thread Group Id) групп процессов, включённых в контрольные группы.
- cgroup.event_control — позволяет отправлять уведомления в случае изменения статуса контрольной группы.
- release_agent — содержится команда, которая будет выполнена, если включена опция notify_on_release. Может использоваться, например, для автоматического удаления пустых контрольных групп.
- notify_on_release — содержит булеву переменную (0 или 1), включающую (или, наоборот, отключающую), выполнение команду, указанной в release_agent.

**blkio (block I/O)**

blkio - это подсистема управления процедурами ввода/вывода блочных устройств. Для ограничения доступа приложению или процессу записываются значения в псевдофайлы. Подсистема содержит огромное количество параметров.

Предлагается рассмотреть наиболее важные:

- blkio.weight - позволяет определить относительный вес (в значениях от 100 до 1000) ввода-вывода контрольной группы. В данном случае, чем больше значение, тем больше ресурсов получит приложение или процесс. Аналогию можно провести довольно простую: при значении 100 приложение получит возможность производить 100 операций чтения/записи в секунду. Можно
определить дополнительное значение для отдельных устройств в отдельный псевдофайл: blkio.weight_device. 
- blkio.weight_device - определяет относительный вес для конкретного устройства, которое доступно в файловой системе. Этот параметр позволяет переопределить общее значение blkio.weight. 

**cpu**

Эта подсистема отвечает за управление доступом контрольных групп к процессорам системы. Доступ регламентируется параметрами, которые так же, как и в предыдущем случае, записываются в псевдофайлы. Принцип такой же: один параметр - один псевдофайл. Рассмотрим наиболее значимые:
- cpu.shares - целочисленный параметр, которые определяет относительную
величину доступного процессорного времени. Например: есть две
контрольные группы. У одной из них это значение равно единице, у второй - 2. Это значит, что процессы из второй контрольной группы будут получать вдвое больше процессорного времени при выполнении той или иной задачи.
- cpu_rt_runtime_us - этим параметром определяется максимальный период времени (в микросекундах), в течение которого задания того или иного процесса могут использовать процессорные ресурсы. Данный параметр очень важен, так как это ограничение позволяет предотвратить монопольное использование ресурсов одной подгруппой.
- cpu._rt_period_us - здесь же определяется интерфал, по истечении которого приложения из контрольной группы получат доступ к процессорным ресурсам.

**cpuacct**

Данная подсистема создает отчеты о занятости ресурсов процессора. Всего имеется три вида отчетов:
- cpuacct.stat - этот отчет возвращает число циклов процессора (величина измерения - USER_HZ), которые были затрачены на обработку заданий контрольной группы. Учитывается пользовательский и системный режим.
- cpuacct.usage - возвращает суммарное время (единица измерения - наносекунды), в течение которого ресурсы процессора были заняты обработкой заданий контрольной группы.
- cpuacct.usage_percpu - как и прошлый отчет, возвращает время, в течение которого ресурсы были заняты обработкой всех заданий контрольной группы, но попроцессорно.

**cpuset**

Подсистема, отвечающая за выделение ресурсов процессора контрольным группам. Также, как и ранее, каждый параметр хранится в отдельном псевдофайле.
Например:
- cpuset.cpus - параметр, определяющий количество процессоров, к которым могут обращаться процессы в контрольной группе. Записывать в файл можно как диапазон используемых процессоров (0-2), так и какие-то отдельные через запятую. Пример: если в файле записано какое-либо число (для простоты - 0), то приложение будет иметь доступ только к этому процессору.
Остальные не будут задействованы для этой задачи. Важно отметить, что этот же процессор может быть задействован для решения и других задач. Если мы хотим, чтобы он был задействован только для решения нашей задачи, используйте следующий параметр.
- cpuset.cpu_exclusive - этим параметром можно задать, возможность совместного использования процессоров, которые были перечислены ранее. 

**devices**

Эта подсистема отвечает за управление доступом к устройствам. Она включена в ОС Linux относительно недавно в отличие от ранее рассмотренных и имеет наименьшее число возможных параметров:
- devices.allow - в этот псевдофайл записываются устройства, к которым разрешен доступ в рамках контрольной группы. Каждая запись содержит по четыре поля: тип устройства, старший номер, младший номер, режим доступа. На первый взгляд кажется, что все сложно, но нет. Давайте рассмотрим каждое поле с примерами:
  - тип устройства. Здесь могут быть следующие значения:
    - a - применяется ко всем символьным и блочным устройствам
    - b - блочное устройство
    - c - символьное устройство (ссылка на устройство, на файл)
  - старший и младший номера - они разделяются двоеточием и
идентифицируют конечное устройство в ОС Linux. Например, значение 8:1 обозначает следующее:
    - 8 - старший номер, обозначающий диски SCSi
    - 1 - младший номер, обозначающий первый раздел на первом
диске
  - режим доступа - определяется доступ к устройству, которое будет иметь контрольная группа, Доступны следующие варианты:
    - r - доступ разрешен только на чтение
    - w - доступ разрешен на чтение и запись
    - m - разрешение доступа на создание файлов, если они не
существуют
- devices.deny - полная противоположность предыдущей опции. Запрещает доступ к устройствам. Формат записи идентичный предыдущему.
- devices.list - в этом псевдофайле будут устройства, для которых было настроено управление доступом.

**freezer**

Из названия может быть понятно, что эта подсистема отвечает за остановку и возобновление заданий контрольной группы. У нее есть всего один псведофайл:
- freezer.state - статус подсистемы. Она имеет несколько допустимых значений:
  - frozen - задания приостановлены
  - freezing - система в стадии приостановки задач
  - thawed - возобновление работы заданий в группе
Важное замечание: в файл можно записать лишь два значения: frozen и thawed. Значение freezing нельзя записать и его система сама записывает в файл. Это состояние - переходное для процесса.

**memory**

Подсистема создает отчеты об использовании ресурсов оперативной памяти. Также позволяет наложить ограничения с помощью ряда параметров. Рассмотрим несколько:
- memory.stat - возвращает статистику использования памяти.
- memory.usage_in_bytes - отображается суммарный размер памяти, которая занята процессами контрольной группы.
- memory.max_usage_in_bytes - максимальный размер памяти, доступный процессам контрольной группы.
- memory.limit_in_bytes - здесь задается максимальный размер памяти, включая файл подкачки.
- memory.failcnt - этот файл является счетчиком случаев достижения лимита, который задается в memory.limit_in_bytes.

**net_cls**

Эта подсистема присваивает сетевым пакетам идентификатор, который помогает контроллеру идентифицировать пакеты, поступающие из контрольной группы. Также можно изменить настройки так, чтобы пакетам из различных групп назначался разный приоритет.
Единственный параметр net_cls.classid представляет из себя
шестнадцатиричное значение, которое идентифицирует обработчик трафика.

**Контейнеры и LXC**

Из приведенного ранее примера должно быть примерно понятно для чего нужны контрольные группы: в них помещаются какие-либо процессы и над ними проводятся различные манипуляции - ограничение ресурсов, запрет на пользование ресурсами либо наоборот разрешение.
