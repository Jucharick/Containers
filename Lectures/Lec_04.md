**Dockerfile**
Каждому образу соответствует свой собственный Dockerfile. Название полностью соответствует произношению (никаких расширений файла). Как уже упоминалось ранее, контейнеры и образы состоят из слоев. Каждый отдельный слой, кроме верхнего (он же - последний), имеет режим доступа “только для чтения”. Также в Dockerfile описывается не только информация о том, что
должно быть в образе, но и в какой именно последовательности это “что-то” добавлять.

**Инструкции Dockerfiles**
- **FROM** Эта инструкция задает родительский (базовый) образ, на основе которого будет формироваться наш собственный.

FROM ubuntu:22.10

- **LABEL** - метка. С ее помощью можно описать метаданные образа. Пример: сведения о том, кто создал данный образ и занимается его поддержкой. Также можно указать контакты при необходимости.

LABEL maintainer="hack-me@list.ru"

- **ENV** - с помощью этой команды можно указать постоянные переменные для среды. С ее помощью можно задавать глобальные переменные, которые будут использоваться в образе и, впоследствии, в запущенном контейнере.

ENV ADMIN="mazzahaker"

- **ARG** - эта инструкция также задает переменные в образе, однако с ее помощью можно задать переменные во время сборки образа.

ARG test_var=script.py

- **RUN** - с помощью этого аргумента можно выполнить команду Linux, создав при этом очередной слой.

RUN apt update

RUN apt upgrade

RUN apt install openssh

- **COPY** - с ее помощью можно скопировать внутрь нашего образа файлы и папки, необходимые для работы.

COPY . ./test123

- **ADD** - она выполняет похожую процедуру: с ее помощью также можно скопировать файлы и папки, а еще распаковать архивы - tar-файлы.

ADD https://github.com/mazzahaker/test-lesson-jenkins/blob/main/pipeline /testdir123

- **WORKDIR** - таким образом можно задать рабочую директорию для
последующих инструкций, описанных в Dockerfile.

  - Рекомендация: в аргументах инструкции лучше указывать абсолютные пути к
  папкам, а не относительные. И уж тем более не перемещаться по файловой
  системе с помощью команд cd в DOCKERFILE.
  - В случае отсутствия директории, указанной в инструкции, система
  автоматически создаст ее.
  - При необходимости в одном докерфайле можно использовать несколько
  инструкций WORKDIR.

- **CMD** - с помощью этого аргумента можно описать команду, которая будет выполняться при запуске контейнера. Эти аргументы можно переопределить при запуске. Об этом моменте мы поговорим дополнительно на практике, так как это излюбленный вопрос на технических собеседованиях.

  - аргументы, введенные в командной строке,
которые передаются при запуске docker run, переопределяют все аргументы запуска, которые предоставляются в докерфайле.
  -  в одном докерфайле может присутствовать только
одна инструкция CMD
  - принято располагать в самом конце файла, что логично,
так как ею и заканчивается описание нашего докерфайла

- **ENTRYPOINT** - предоставляет команду с набором аргументов для вызова во время выполнения контейнера. Эти аргументы нельзя переопределить. На практике мы повторно рассмотрим этот момент и все станет намного понятнее.

  - Если при каждом запуске контейнера необходимо выполнять одну и ту же
команду раз за разом, то необходимо использовать ENTRYPOINT.
  - В случае, если контейнер используется в роли приложения (запуск БД, к
примеру), также необходимо использовать ENTRYPOINT.
  - Если мы знаем, что во время запуска контейнера необходимо передавать ему
аргументы, которые могут перезаписывать аргументы по умолчанию
(изменять параметры запуска, к примеру), используйте CMD.

ENTRYPOINT ["python", "test_var"]

- **EXPOSE** - об этой инструкции нам уже известно и мы рассматривали ее на предыдущем уроке и семинарах. Она указывает на необходимость открытия порта.

Для того, чтобы открыть какой-либо порт (ну или группу портов) и настроить перенаправление портов необходимо как и раньше использовать команду docker run с ключом -p, который и указывает на необходимость открытия портов у контейнера.

EXPOSE 8080

- **VOLUME** - позволяет создать точку монтирования для работы с каким-либо внешним хранилищем.
Данная инструкция позволяет указывать место в локальной системе, которое контейнер будет использовать для хранения данных.


sudo apt install cowsay

/usr/games/cowsay "GeekBrains"

      FROM ubuntu:22.10
      RUN apt-get update
      RUN apt-get install -y cowsay
      RUN ln -s /usr/games/cowsay /usr/bin/cowsay
      CMD [“cowsay”]

docker build -t cowsaytest 


**Проверяем:**

docker run -it cowsaytest bash

1. Что мы находимся внутри контейнера:

ps -aux

hostname

Выходим из контейнера в хостовую ОС и запустим наш контейнер из
созданного образа:

docker run cowsaytest cowsay “GeekBrains”

Теперь же давайте посмотрим на наши образы:

root@testVM:~# docker images

REPOSITORY TAG IMAGE ID CREATED SIZE

cowsaytest latest bd5b2cacc57b 6 seconds ago 152MB

**Давайте поправим наш докерфайл:**

      FROM ubuntu:22.10
      RUN apt-get update && \
      apt-get install -y cowsay && \
      ln -s /usr/games/cowsay /usr/bin/cowsay
      RUN rm -rf /var/lib/apt/lists/*

**Давайте проверим результат, запустив сборку контейнера:**

docker build -t cowsaytest .

**Теперь система показывает, что у нас 3 шага вместо пяти. Давайте взглянем на размер:**

      root@testVM:~# docker images
      REPOSITORY TAG IMAGE ID CREATED SIZE
      cowsaytest latest 7afc9495be91 4 seconds ago 152MB

**Теперь давайте еще раз исправим наш докерфайл:**

      FROM ubuntu:22.10
      RUN apt-get update && \
      apt-get install -y cowsay && \
      ln -s /usr/games/cowsay /usr/bin/cowsay && \
      rm -rf /var/lib/apt/lists/*
      CMD [“cowsay”]

**Пересоберем наш контейнер и посмотрим на размер:**

docker build -t cowsaytest 

      root@testVM:~# docker images
      REPOSITORY TAG IMAGE ID CREATED SIZE
      cowsaytest latest 6067ef1e4752 7 seconds ago 118MB
      <none> <none> 7afc9495be91 3 minutes ago 152MB


Предыдущий контейнер весил 152 Мб, а наш текущий - 118 Мб. Это прогресс! Однако, все равно чересчур много для простого приложения, которое изначально весит около 5 Мб.

**Изначально это большая ошибка новичков: мы использовали базовый образ той системы, которая у всех на слуху, однако, для
сборки необходимо использовать более легковесные образы. Например, alpine.**

Давайте проверим:

      FROM alpine
      RUN apt-get update && \
      apt-get install -y cowsay && \
      ln -s /usr/games/cowsay /usr/bin/cowsay && \
      rm -rf /var/lib/apt/lists/*
      CMD [“cowsay”]

Соберем образ:

docker build -t cowsaytest

./bin/sh: apt-get: not found

**Давайте еще раз поправим наш докерфайл:**

      FROM alpine
      RUN apk update && apk add cowsay \
      --update-cache \
      --repository
      https://alpine.global.ssl.fastly.net/alpine/edge/community \
      --repository
      https://alpine.global.ssl.fastly.net/alpine/edge/main \
      --repository
      https://dl-3.alpinelinux.org/alpine/edge/testing && \
      rm -rf /var/cache/apk/*
      CMD [“cowsay”]

**Соберем образ и проверим размер:**

      root@testVM:~# docker images
      REPOSITORY TAG IMAGE ID CREATED
      SIZE cowsaytest latest 0eb4784817d6 4 seconds ago
      40.9MB

Идеально! В нашем примере размер уменьшился в 4 раза.