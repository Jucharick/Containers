**Docker Compose (ДК)** - позволяет управлять несколькими контейнерами из одного yml-файла. ДК - это инструментальное средство, которое находится в составе докера. Следует напомнить, что основное его предназначение - решение задач по развертыванию проектов, состоящих из одного или нескольких контейнеров. В рамках одного запуска нет ограничений на количество сущностей.

**Основные команды ДК**
- docker-compose build - команда позволяет собрать сервисы, описанные в конфигурационных файлах
- docker-compose up -d - запускает наш проект. В данном случае проект запустится в фоновом режиме, так как в команде присутствует флаг -d
- docker-compose start - запускает любые остановленные ранее сервисы в соответствии с указанными параметрами
- docker-compose down - останавливает наш проект и, что немаловажно, удаляет все сервисы, которые были запущены ранее
- docker-compose stop - эта команда просто останавливает все сервисы, описанные в конфигурации. Она не удаляет контейнеры, тома, сети и прочие сущности, описанные в конфигурационном файле
- docker-compose logs -f [service name] - с помощью этой команды можно посмотреть логи нашего сервиса
- docker-compose ps - выводит на экран список всех доступных контейнеров
- docker-compose exec [service name] [command] - с ее помощью можно выполнить команду в сервисе, не заходя при этом в контейнер. Ранее мы рассматривали подобное на уроке “Введение в Docker”
- docker-compose images - позволяет вывести список образов.



**YAML** — это язык для сериализации данных. Позволяет хранить сложноорганизованные данные в компактном
и читаемом формате.
**YAML** — это язык для хранения информации в формате понятном человеку.

YAML — это язык для сериализации данных, который отличается простым синтаксисом и позволяет хранить сложноорганизованные данные в компактном и читаемом формате.

YAML — это язык для хранения информации в формате, понятном человеку. Его название расшифровывается как, «Ещё один язык разметки». Однако, позже расшифровку изменили на — «YAML не язык разметки», чтобы отличать его от настоящих языков разметки.

Язык похож на XML и JSON, но использует более минималистичный синтаксис при сохранении аналогичных возможностей. YAML обычно применяют для создания конфигурационных файлов в программах типа Инфраструктура как код (Iac), или для управления контейнерами в работе DevOps.

**Особенности YAML**
- Понятный человеку код
- Минималистичный синтаксис
- Заточен под работу с данными
- Встроенный стиль, похожий на JSON
- Поддерживает комментарии
- Поддерживает строки без кавычек
- Считается «чище», чем JSON
- Дополнительные возможности

**Оркестрация контейнеров** — это централизованное и эффективное управление, а также - мониторинг контейнеров.

### Инструмент оркестрации (оркестратор)
Ключевые элементы:
- Развертывание

Развертывание - это возможность эффективно деплоить наши контейнеры в соответствии с заданными параметрами. Оно обычно осуществляется с помощью манифестов. Манифест — это файл JSON, содержащий всю информацию о контейнерах Docker, которые необходимо развернуть.

- Масштабирование

Под масштабированием здесь стоит понимать возможность увеличения
количества запущенных контейнеров простым способом. Например, если у нас есть контейнер, в котором работает веб-сервер (или БД), и трафик растет, мы можем масштабировать его и дублировать один и тот же контейнер столько раз, сколько необходимо для удовлетворения всех входящих запросов. Масштабирование работает не только в сторону роста, количество реплик контейнера также может быть уменьшено, если, например, уменьшится трафик.
Также сюда стоит включить умение управлять внутренней сетью. Это также немаловажно, так как контейнеры чаще всего - это одноразовые сущности, которые запускаются и останавливаются в соответствии с конкретными потребностями приложения и запросов, поступающих к нему.

- Надежность

Теперь давайте поговорим о надежности. Помимо всего прочего, оркестратор должен быть способен поддерживать работоспособность нашего приложения. Что здесь имеется ввиду: как только мы объявим контейнеры, которые необходимо развернуть для нашего приложения, оркестратор должен позаботиться о том, чтобы
были развернуты они и вся инфраструктура, которая необходима. Учитывая, что в зависимости от нагрузки контейнеры могут быть развернуты дополнительно либо удалены (лишние имеется в виду), оркестратор также должен быть способен выполнять эти задачи автоматически: поднимать дополнительные контейнеры, останавливать избыточные, чтобы экономить ресурсы.


### Docker Swarm

- Отказоустойчивость - при выходе из строя одной ноды из трех, наши контейнеры смогут продолжать работу на остальных узлах кластера
- Увеличение ресурсов - в случае работы в кластере, существенно увеличивается мощность, доступная контейнерам для работы

**Node (нода)** - это наш сервер с установленным на нем Docker. По сути, нодой могут быть как физические сервера, так и виртуальные машины.

**Stack** - это набор сервисов, которые могут быть связаны между собой логически. Иными словами, это набор сервисов, которые описываются в обычном compose файле. Важно заметить, что части стека могут располагаться как на одной ноде, так и на различных

**Сервис** - это составляющая стека. Сервис является описанием того, какие контейнеры необходимо создать. Ранее мы уже рассмотрели ДК файлы и, по сути, на практике познакомились с этой сущностью.

**Task (задача)** - непосредственно созданный контейнер, который движок докера создает на основе предоставленной информации.

Компоненты
- Stack - это набор сервисов, которые могут быть связаны между собой логически
- Сервис - это составляющая стэка
- Task (задача) - непосредственно созданный контейнер

### Overlay сети

- Overlay - создает простую подсеть, которая может быть  спользована контейнерами на разных хостах swarm-кластера
- ingress - этот тип сети используется в ДС по умолчанию при создании кластера. Она отвечает за связи, которые  станавливаются между контейнерами и внешним миром
- vxlan - при использовании этого типа сетей, у нас 
не просто происходит создание Overlay-сети. В этом случае происходит инкапсуляция пакетов 2 слоя модели OSI в четвертый
- docker_gwbridge - эта сеть создается на каждом узле кластера. 

У ДС есть два типа нод (узлов):
- manager node - управляющий сервер. Он способен управлять нашим
кластером: добавлять и удалять сущности (например, ноды кластера). На нем также возможно запускать и контейнеры.
- worker node - на этом узле возможен лишь запуск контейнеров. Управление кластера с данного типа узлов недоступен.

**Советы по использованию Docker Compose и Docker Swarm**

1. используйте виртуальные сети для различных проектов

Изоляция сетей
- Разные наборы окружений = разные сети.
Полная изоляция пакетов данных
- Ограничение прослушивания адреса 0.0.0.0
- Разграничение сред выполнения

2. - Корректно открывать порты, не используя адрес 0.0.0.0

Проброс портов (NAT). Пример проброса портов:
- 8080:80
- 127.0.0.1:8080:8080



      docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:8.0.31

      docker run --name myphp -d --link some-mysql:db -p 8081:80
      phpmyadmin/phpmyadmin


YAML-файл, который мы будем использовать на практике.

      version: ‘3.9’
      services:
        db:
          image: mariadb:10.10.2
          restart: always
          environment:
            MYSQL_ROOT_PASSWORD: 12345
        adminer:
          image: adminer:4.8.1
          restart: always
          ports:
            - 6080:8080

В целом, манифест довольно прост. Давайте перейдем к комментариям и описанию:

- version: ‘3.9’ - в этой строке описывается версия compose-файла. Каждый файл обязательно должен начинаться с тега версии. Глобально версий всего три. Первая, которая более не поддерживается, вторая и третья. Каждой версии файла соответствует определенная версия докера, установленная на
машине. Например, для версии 3.1 необходимо, чтобы становленный докер был не ниже версии 1.13.1, а вот версия 3.8 уже требует минимум версию 19.03.0.
- services - эта строка говорит о том, что далее в файле будут описаны сервисы (один или несколько), которые необходимо запустить или остановить (зависит от команды, передаваемой в докер). Важно помнить, что ДК работает с сервисами (1 сервис = 1 контейнер). Сервисом при этом может быть клиент, сервер, сервер БД и так далее.
- db: - это название первого сервиса. Название каждый может придумать какое угодно вам. Понятное название сервиса поможет определить его роль и сделать манифесты более читаемыми.
- build: ./db - ключевое слово, позволяющее задать путь к файлу докерфайл, который будет использован для создания собственного образа и который, в свою очередь, позволит запустить сервис.
- image: mariadb - если вместо build указан этот вариант, система будет использовать готовые образы с docker hub. На лекции, в примерах, мы будем использовать этот вариант. На практике попробуем разобрать варианты с построением собственных образов.
- restart: always - позволяет определить политику перезапуска контейнера. Существует несколько вариантов:
    - no - не перезапускать контейнер автоматически. Это значение по     умолчанию. Если мы ничего не укажем, контейнер не будет перезапускаться
    - on-failure [max retries] - перезапускать контейнер, если он был завершен не с нулевым кодом выхода. В данном случае необходимо указать максимальное количество попыток перезапуска
    - always - всегда перезапускать контейнер, если он был остановлен. Здесь стоит быть аккуратнее в связи с тем, что в этом случае возможен цикличный перезапуск контейнера с проблемами
    - unless-stopped - всегда перезапускать контейнер. По сути, этот вариант аналогичен always кроме случаев, когда он был остановлен вручную.При этом он не перезапускается после перезапуска демона докера.
    - environment - в этом блоке прописываются переменные, которые могут быть использованы для работы контейнера
    - ports - указывает на то, какие порты необходимо открыть для связи с контейнером.



Первым делом проверим, что у нас ничего не запущено:

    docker ps -a


    docker-compose up -d

    docker container inspect adminer

    docker container inspect mariadb

    docker ps

    docker-compose stop #здесь показать, что контейнеры были остановлены, но не удалены!

    docker ps -a #отображаем остановленные контейнеры

    docker-compose start -d #снова запускаем и проверяем, что все хорошо

    docker-compose logs #показать, что логи тоже есть
    
    Start existing containers. #заострить внимание на этом!

    docker ps -a

    docker-compose down #показать, что в этом случае они удалятся

    docker ps -a #проверяем удаление

    docker-compose start #пытаемся запустить удаленное и получаем ошибку

                Starting db ... failed
                Starting adminer ... failed
                ERROR: No containers to start
                ERROR: 1


Теперь давайте инициализируем наш кластер:
      
    docker swarm init
В ответ на это мы получили следующую команду:

    docker swarm join --token
    SWMTKN-1-3un77cn4m5ok3ijrdouwg3mit69uwmfwx96krc7taua7ovpjha-97y4zk9ppc8hxk2caxlig23xo 192.168.50.90:2377


Теперь, когда все команды выполнены успешно, давайте проверим состояние нашего кластера:

    docker node ls

Однако, у нас есть еще одна нода. Давайте добавим и ее.

    docker swarm join --token
    SWMTKN-1-3un77cn4m5ok3ijrdouwg3mit69uwmfwx96krc7taua7ovpjha-97y4zk9ppc8hxk2caxlig23xo 192.168.50.90:2377

    docker node ls

Отлично, она добавлена. Теперь давайте выведем ее из кластера:

    docker swarm leave  

Теперь давайте посмотрим, в каком статусе содержится нода:

    docker node ls # необходимо немного времени

Для того, чтобы можно было окончательно удалить эту ноду, нужно выполнить на менеджере:

    docker node rm (ID ноды)

Давайте теперь запустим контейнер и подключим его к нашей
сети.

    docker run -d --ip 4.5.6.7 --net test-network --name
    container-1 busybox sleep 3600

Давайте следом запустим второй, но на другой ноде:

    docker run -d --ip 4.5.6.8 --net test-network --name
    container-2 busybox sleep 3600


Теперь же давайте войдем внутрь первого контейнера и выполним проверку доступности.

    docker exec -it container-1 sh

Внутри:
    ping 4.5.6.7


    